# Teacher Choice Dashboard API Views
# DEPRECATED: Layer 2 Gas-Free TeoCoin System removed

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import api_view, permission_classes
from django.shortcuts import get_object_or_404
from django.utils import timezone
from datetime import timedelta
import logging
import json

# LEGACY IMPORT REMOVED - gas_free_v2_service no longer available
# from services.gas_free_v2_service import GasFreeV2Service

from users.models import User
from courses.models import Course
from notifications.services import teocoin_notification_service

logger = logging.getLogger(__name__)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def teacher_pending_choices(request):
    """Get all pending discount requests waiting for teacher decision"""
    try:
        teacher = request.user
        
        # Get pending requests for this teacher (expires in 2 hours)
        cutoff_time = timezone.now() - timedelta(hours=2)
        
        pending_requests = DiscountRequest.objects.filter(
            teacher_address__iexact=getattr(teacher, 'wallet_address', ''),
            status='pending',
            created_at__gte=cutoff_time
        ).order_by('-created_at')
        
        # Format response data
        choices_data = []
        for request_obj in pending_requests:
            try:
                course = Course.objects.get(id=request_obj.course_id)
                student = User.objects.filter(wallet_address__iexact=request_obj.student_address).first()
                
                # Calculate teacher rewards
                teo_amount = request_obj.teo_cost
                teo_bonus = teo_amount * 0.25  # 25% bonus
                total_teo = teo_amount + teo_bonus
                
                # Calculate fiat amounts based on teacher's staking tier
                original_price = request_obj.course_price
                discounted_price = original_price * (100 - request_obj.discount_percent) / 100
                
                # Get teacher's staking tier (simplified for now)
                teacher_commission = 0.75  # Assume Diamond tier for now
                
                choice_data = {
                    'request_id': request_obj.request_id,
                    'course_title': course.title,
                    'course_price': original_price,
                    'discount_percent': request_obj.discount_percent,
                    'student_name': student.get_full_name() if student else 'Anonymous',
                    'student_address': request_obj.student_address,
                    'created_at': request_obj.created_at.isoformat(),
                    'expires_at': (request_obj.created_at + timedelta(hours=2)).isoformat(),
                    'teo_cost': teo_amount,
                    'choices': {
                        'accept_teo': {
                            'description': 'Accept TeoCoin Payment',
                            'fiat_amount': discounted_price * teacher_commission,
                            'teo_amount': total_teo,
                            'teo_bonus': teo_bonus,
                            'benefits': [
                                f'Receive {total_teo} TEO total',
                                f'Build toward higher staking tier',
                                f'Support platform token economy'
                            ]
                        },
                        'decline_teo': {
                            'description': 'Decline TeoCoin, Get Full Fiat',
                            'fiat_amount': original_price * teacher_commission,
                            'teo_amount': 0,
                            'benefits': [
                                f'Receive full {original_price * teacher_commission}€',
                                'Predictable fiat income',
                                'Platform absorbs TEO cost'
                            ]
                        }
                    }
                }
                choices_data.append(choice_data)
                
            except Exception as e:
                logger.error(f"Error processing request {request_obj.id}: {e}")
                continue
        
        return Response({
            'success': True,
            'pending_choices': choices_data,
            'total_pending': len(choices_data),
            'teacher_address': getattr(teacher, 'wallet_address', ''),
            'message': f'Found {len(choices_data)} pending discount choices'
        })
        
    except Exception as e:
        logger.error(f"Error getting teacher pending choices: {e}")
        return Response({
            'success': False,
            'error': 'Failed to get pending choices',
            'details': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def teacher_accept_teo_choice(request):
    """Teacher chooses to accept TEO payment"""
    try:
        teacher = request.user
        request_id = request.data.get('request_id')
        
        if not request_id:
            return Response({
                'success': False,
                'error': 'Missing request_id'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate request exists and belongs to teacher
        try:
            discount_request = DiscountRequest.objects.get(
                request_id=request_id,
                teacher_address__iexact=getattr(teacher, 'wallet_address', ''),
                status='pending'
            )
        except DiscountRequest.DoesNotExist:
            return Response({
                'success': False,
                'error': 'Discount request not found or not pending'
            }, status=status.HTTP_404_NOT_FOUND)
        
        # Check if request has expired (2 hours)
        expiry_time = discount_request.created_at + timedelta(hours=2)
        if timezone.now() > expiry_time:
            return Response({
                'success': False,
                'error': 'Request has expired'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Execute teacher choice via Gas-Free V2 service
        gas_free_service = GasFreeV2Service()
        result = gas_free_service.teacher_accept_teo(request_id, teacher.wallet_address)
        
        if result['success']:
            # Update database
            discount_request.status = 'teacher_accepted_teo'
            discount_request.teacher_choice_at = timezone.now()
            discount_request.save()
            
            # Calculate rewards
            teo_amount = discount_request.teo_cost
            teo_bonus = teo_amount * 0.25
            total_teo = teo_amount + teo_bonus
            
            logger.info(f"✅ Teacher {teacher.wallet_address} accepted TEO for request {request_id}")
            
            return Response({
                'success': True,
                'message': 'TEO payment accepted successfully!',
                'request_id': request_id,
                'teo_received': total_teo,
                'teo_bonus': teo_bonus,
                'tx_hash': result['tx_hash'],
                'teacher_gas_cost': '0 MATIC (Gas-free!)',
                'platform_gas_cost': f"~$0.002 MATIC"
            })
        else:
            return Response({
                'success': False,
                'error': result['error']
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
    except Exception as e:
        logger.error(f"Teacher accept TEO error: {e}")
        return Response({
            'success': False,
            'error': 'Failed to accept TEO payment',
            'details': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def teacher_decline_teo_choice(request):
    """Teacher chooses to decline TEO, get full fiat payment instead"""
    try:
        teacher = request.user
        request_id = request.data.get('request_id')
        
        if not request_id:
            return Response({
                'success': False,
                'error': 'Missing request_id'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate request exists and belongs to teacher
        try:
            discount_request = DiscountRequest.objects.get(
                request_id=request_id,
                teacher_address__iexact=getattr(teacher, 'wallet_address', ''),
                status='pending'
            )
        except DiscountRequest.DoesNotExist:
            return Response({
                'success': False,
                'error': 'Discount request not found or not pending'
            }, status=status.HTTP_404_NOT_FOUND)
        
        # Check if request has expired (2 hours)
        expiry_time = discount_request.created_at + timedelta(hours=2)
        if timezone.now() > expiry_time:
            return Response({
                'success': False,
                'error': 'Request has expired'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Execute teacher choice via Gas-Free V2 service
        gas_free_service = GasFreeV2Service()
        result = gas_free_service.teacher_decline_teo(request_id, teacher.wallet_address)
        
        if result['success']:
            # Update database
            discount_request.status = 'teacher_declined_teo'
            discount_request.teacher_choice_at = timezone.now()
            discount_request.save()
            
            # Calculate fiat payment (full course price)
            original_price = discount_request.course_price
            teacher_commission = 0.75  # Assume Diamond tier
            fiat_payment = original_price * teacher_commission
            
            logger.info(f"✅ Teacher {teacher.wallet_address} declined TEO for request {request_id}")
            
            return Response({
                'success': True,
                'message': 'TEO declined - you will receive full fiat payment!',
                'request_id': request_id,
                'fiat_payment': fiat_payment,
                'tx_hash': result['tx_hash'],
                'note': 'Platform absorbs TEO cost, student still gets discount',
                'teacher_gas_cost': '0 MATIC (Gas-free!)',
                'platform_gas_cost': f"~$0.002 MATIC"
            })
        else:
            return Response({
                'success': False,
                'error': result['error']
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
    except Exception as e:
        logger.error(f"Teacher decline TEO error: {e}")
        return Response({
            'success': False,
            'error': 'Failed to decline TEO payment',
            'details': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def teacher_choice_history(request):
    """Get teacher's historical choices and earnings"""
    try:
        teacher = request.user
        
        # Get all completed requests for this teacher
        completed_requests = DiscountRequest.objects.filter(
            teacher_address__iexact=getattr(teacher, 'wallet_address', ''),
            status__in=['teacher_accepted_teo', 'teacher_declined_teo']
        ).order_by('-teacher_choice_at')[:50]  # Last 50 choices
        
        # Calculate summary statistics
        total_teo_accepted = 0
        total_fiat_declined = 0
        choices_summary = []
        
        for request_obj in completed_requests:
            try:
                course = Course.objects.get(id=request_obj.course_id)
                
                if request_obj.status == 'teacher_accepted_teo':
                    teo_amount = request_obj.teo_cost
                    teo_bonus = teo_amount * 0.25
                    total_teo = teo_amount + teo_bonus
                    total_teo_accepted += total_teo
                    
                    choice_data = {
                        'request_id': request_obj.request_id,
                        'course_title': course.title,
                        'choice': 'accepted_teo',
                        'teo_received': total_teo,
                        'date': request_obj.teacher_choice_at.isoformat(),
                        'discount_percent': request_obj.discount_percent
                    }
                else:  # declined_teo
                    teacher_commission = 0.75  # Assume Diamond tier
                    fiat_amount = request_obj.course_price * teacher_commission
                    total_fiat_declined += fiat_amount
                    
                    choice_data = {
                        'request_id': request_obj.request_id,
                        'course_title': course.title,
                        'choice': 'declined_teo',
                        'fiat_received': fiat_amount,
                        'date': request_obj.teacher_choice_at.isoformat(),
                        'discount_percent': request_obj.discount_percent
                    }
                
                choices_summary.append(choice_data)
                
            except Exception as e:
                logger.error(f"Error processing historical request {request_obj.id}: {e}")
                continue
        
        return Response({
            'success': True,
            'choice_history': choices_summary,
            'summary': {
                'total_choices': len(choices_summary),
                'total_teo_accepted': total_teo_accepted,
                'total_fiat_from_declines': total_fiat_declined,
                'acceptance_rate': len([c for c in choices_summary if c.get('choice') == 'accepted_teo']) / max(len(choices_summary), 1) * 100
            },
            'teacher_address': getattr(teacher, 'wallet_address', '')
        })
        
    except Exception as e:
        logger.error(f"Error getting teacher choice history: {e}")
        return Response({
            'success': False,
            'error': 'Failed to get choice history',
            'details': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
